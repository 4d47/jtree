todo Add comments?
todo Make run in browser
todo Add print or tracer type of intermediate element. debugger?
anyCell
 highlightScope string
 examples lorem ipsum
assertionKeywordCell
 highlightScope keyword.operator
 extends keywordCell
commandCell
 extends keywordCell
 highlightScope variable.function
 examples someCommand
extraCell
 highlightScope invalid
filepathCell
 examples foobar.foo someFile.foo
 highlightScope string
keywordCell
hashBangKeywordCell
 extends keywordCell
 highlightScope comment
 enum #!
hashBangCell
 highlightScope comment
intCell
 regex \-?[0-9]+
 highlightScope constant.numeric.integer
parameterKeywordCell
 extends keywordCell
 highlightScope variable.parameter
todoCell
 highlightScope comment
todoKeywordCell
 extends keywordCell
 highlightScope comment
typeOfOptionCell
 description The 6 possible results for Javascript's typeof.
 highlightScope constant.language
 enum object boolean function number string undefined
swarmNode
 root
 description A prefix Tree Language for unit testing.
 inScope hashbangNode arrangeNode abstractTestBlockNode
 catchAllNodeType errorNode
 javascript
  getCommandParent(testSubject) {
   return testSubject
  }
  getTestSetupNode() {
   return this.getChildInstancesOfNodeTypeId("arrangeNode")[0]
  }
  async execute(filepath) {
   const tree = new jtree.TestRacer(this.compileToRacer(filepath))
   await tree.execute()
   tree.finish()
  }
  compileToRacer(filepath) {
   const testBlocks = {}
   this.getTestsToRun().forEach(testNode => {
    testBlocks[testNode.getContent()] = testNode.execute(filepath)
   })
   const files = {}
   files[filepath] = testBlocks
   return files
  }
  getTestsToRun() {
   const solos = this.getChildInstancesOfNodeTypeId("testOnlyNode")
   return solos.length ? solos : this.getChildInstancesOfNodeTypeId("abstractTestBlockNode").filter(test => !test.doesExtend("skipTestNode"))
  }
abstractAssertionNode
 abstract
 javascript
  async execute(testSubject) {
   const finalParts = jtree.Utils.getMethodFromDotPath(testSubject, this.getWord(1))
   const subject = finalParts[0]
   const command = finalParts[1]
   const actual = subject[command]()
   const actualAsString = this.parseActual(actual).toString()
   const expected = this.getExpected()
   this.getTestResult(actualAsString, expected, this.getLine())
  }
  equal(actual, expected, message) {
   this.getParent().getEqualFn()(actual, expected, message)
  }
  getTestResult(actualAsString, expected, message) {
   this.equal(actualAsString, expected, message)
   return actualAsString === expected
  }
  parseActual(actual) {
   return actual
  }
  executeSync(result) {
   const expected = this.getSyncExpected()
   const actual = this.parseActual(result)
   const actualIsUndefined = actual === undefined
   const actualAsString = actualIsUndefined ? "undefined" : actual.toString()
   this.getTestResult(actualAsString, expected, this.getLine())
  }
  getExpected() {
   return this.getWordsFrom(2).join(" ")
  }
  getSyncExpected() {
   return this.getContent()
  }
 cells assertionKeywordCell
blockStringIsNode
 crux blockStringIs
 description When your expected value is a multiline string.
 catchAllNodeType textBlockNode
 javascript
  getExpected() {
   return this.childrenToString()
  }
  getSyncExpected() {
   return this.childrenToString()
  }
 extends abstractAssertionNode
lengthIsNode
 crux lengthIs
 description Intake is an array, and checks if the length of array matches expected.
 cells assertionKeywordCell intCell
 javascript
  parseActual(actual) {
   return actual.length
  }
 extends abstractAssertionNode
stringExcludesNode
 crux stringExcludes
 description Converts the input to string and ensure the string does NOT contain the provided string
 catchAllCellType anyCell
 javascript
  getTestResult(actualAsString, expected, message) {
   const result = !actualAsString.includes(expected)
   if (!result) {
    const index = actualAsString.indexOf(expected)
    const start = Math.max(0, index - 50)
    message += ` Found ${expected} in: ` + actualAsString.substr(start, index + 50 + expected.length)
   }
   this.equal(result, true, message)
   return result
  }
 extends abstractAssertionNode
stringIncludesNode
 crux stringIncludes
 catchAllCellType anyCell
 description Converts the input to string and see if the string contains the provided string
 javascript
  getTestResult(actualAsString, expected, message) {
   const result = actualAsString.includes(expected)
   this.equal(result, true, message)
   return result
  }
 extends abstractAssertionNode
stringIsNode
 crux stringIs
 description Intake is anything with a toString method, and compares that to provided expected value.
 catchAllCellType anyCell
 extends abstractAssertionNode
typeIsNode
 crux typeIs
 description Assert result is one of Javascript's 6 typeof types.
 cells assertionKeywordCell typeOfOptionCell
 javascript
  parseActual(actual) {
   return typeof actual
  }
 extends abstractAssertionNode
abstractTerminalNode
 abstract
 cells keywordCell
asyncNode
 description Set this in setup to test async methods.
 extends abstractTerminalNode
 crux async
requireNode
 crux require
 cells keywordCell filepathCell
 catchAllCellType anyCell
 extends abstractTerminalNode
staticNode
 crux static
 description Add this to setup node to import class directly without initiating it, for static method testing.
 extends abstractTerminalNode
abstractTestBlockNode
 catchAllCellType anyCell
 javascript
  getTestSetupNode() {
   return this.getNode("arrange") || this.getParent().getTestSetupNode()
  }
  isAsync() {
   return this.getTestSetupNode().has("async")
  }
  setEqualMethod(equal) {
   this._equal = equal
   return this
  }
  getTestBlock() {
   return this
  }
  getEqualFn() {
   return this._equal
  }
  execute(programFilepath) {
   const testSubject = this.getTestSetupNode().getTestSubject(programFilepath)
   const isAsync = this.isAsync()
   const executeMethod = isAsync ? "execute" : "executeSync"
   return async equal => {
    this.setEqualMethod(equal)
    const promises = this.map(async child => {
     const result = await child[executeMethod](testSubject)
     return result
    })
    await Promise.all(promises)
   }
  }
 inScope arrangeNode
 catchAllNodeType commandNode
 abstract
 cells keywordCell
testNode
 description Basic test block.
 extends abstractTestBlockNode
 crux test
testOnlyNode
 description If set, only this test block will be run.
 extends abstractTestBlockNode
 crux testOnly
skipTestNode
 description If you want to skip running a test.
 javascript
  async execute() {
   console.log(`Skipped test ${this.getLine()}`)
  }
 extends abstractTestBlockNode
 crux skipTest
hashbangNode
 crux #!
 description Standard bash hashbang line.
 cells hashBangKeywordCell hashBangCell
 catchAllCellType hashBangCell
arrangeNode
 crux arrange
 javascript
  getTestSubject(programFilepath) {
   const requiredClass = this._getRequiredClass(programFilepath)
   const constructorArgNode = this.getChildInstancesOfNodeTypeId("constructWithBlockStringNode")[0]
   const param = constructorArgNode ? constructorArgNode.childrenToString() : undefined
   return this.has("static") ? requiredClass : new requiredClass(param)
  }
  _getRequiredClass(programFilepath) {
   let requiredClass =
    this.get("require") ||
    this.getRootNode()
     .getNode("arrange")
     .get("require")
   const requiredClassParts = requiredClass.split(" ") // Allows for ./ExportsClasses.js ChildClass
   requiredClass = requiredClassParts[0]
   let theClass
   if (this.isNodeJs()) theClass = require(jtree.Utils.resolvePath(requiredClass, programFilepath))
   else theClass = window[jtree.Utils.getClassNameFromFilePath(requiredClass)]
   if (requiredClassParts[1]) theClass = jtree.Utils.resolveProperty(theClass, requiredClassParts[1])
   if (!theClass) throw new Error(`Required class '${requiredClassParts.join(" ")}' not found for ${this.toString()}`)
   return theClass
  }
  executeSync() {}
 inScope asyncNode requireNode staticNode constructWithBlockStringNode todoNode
 cells keywordCell
abstractCommandArgNode
 abstract
 javascript
  executeSync() {}
blockStringParamNode
 description Pass in a multiline string as a command arg. #todo: rename
 extends abstractCommandArgNode
 catchAllNodeType textBlockNode
 cells parameterKeywordCell
 crux blockStringParam
commandNode
 javascript
  getTestBlock() {
   return this.getParent()
  }
  getEqualFn() {
   return this.getTestBlock().getEqualFn()
  }
  _getArgs() {
   const argNodes = this.getChildInstancesOfNodeTypeId("abstractCommandArgNode")
   if (argNodes.length) return argNodes.map(arg => arg.childrenToString())
   return this.getWordsFrom(1)
  }
  _executeSwarmCommand(testSubject) {
   const commandName = this.getFirstWord()
   const commandParent = this.getRootNode().getCommandParent(testSubject) // todo: hacky.
   const commandFn = commandParent[commandName]
   if (!commandFn) throw new Error(`No function "${commandName}" on "${commandParent.constructor.name}"`)
   return commandFn.apply(commandParent, this._getArgs())
  }
  async execute(testSubject) {
   await this._executeSwarmCommand(testSubject)
   return super.execute(testSubject) // note: this might not work with closure compiler b/c of bug #2652
  }
  executeSync(testSubject) {
   const newTestSubject = this._executeSwarmCommand(testSubject)
   return this.map(child => child.executeSync(newTestSubject))
  }
 description Input is an object, and calls some method with an optional array of string args.
 catchAllCellType anyCell
 catchAllNodeType commandNode
 inScope blockStringParamNode abstractAssertionNode
 cells commandCell
constructWithBlockStringNode
 javascript
  executeSync() {}
 description Pass in a multiline string to setup constructor. #todo: rename
 catchAllNodeType textBlockNode
 cells keywordCell
 crux constructWithBlockString
errorNode
 baseNodeType errorNode
textBlockNode
 catchAllCellType anyCell
 catchAllNodeType textBlockNode
 cells anyCell
todoNode
 description Todos let you add notes about what is coming in the future in the source code. They are like comments in other languages except should only be used for todos.
 catchAllCellType todoCell
 catchAllNodeType todoNode
 crux todo
 cells todoKeywordCell